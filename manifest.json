{
  "id": "animeworldindia",
  "name": "AnimeWorldIndia",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/sabbir404M/mangayomi-ani-extensions/refs/heads/main/manifest.json",
  "language": "typescript",
  "type": "onlinestream-provider",
  "description": "AnimeWorldIndia - Hindi dubbed and subbed anime streaming with multi-language support.",
  "author": "Swakshan",
  "icon": "https://raw.githubusercontent.com/RyanYuuki/AnymeX/main/assets/images/logo.png",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private baseUrl = \"https://watchanimeworld.in\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    const normalize = (title: string) => {\n      return (title || \"\")\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, \"\")\n        .replace(/(season|cour|part)/g, \"\");\n    };\n\n    const searchUrl = `${this.baseUrl}/search.html?keyword=${encodeURIComponent(query.query)}`;\n    const html = await fetch(searchUrl, {\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n        \"Referer\": this.baseUrl,\n      },\n    }).then(res => res.text());\n\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, \"text/html\");\n    const items = doc.querySelectorAll(\"div.flw-item\");\n\n    const results: SearchResult[] = [];\n    for (const item of items) {\n      const titleEl = item.querySelector(\"h3.film-name a\");\n      const slugEl = item.querySelector(\"a\");\n      if (titleEl && slugEl) {\n        const title = titleEl.textContent?.trim() || \"\";\n        const slug = slugEl.getAttribute(\"href\")?.replace(this.baseUrl, \"\") || \"\";\n        const id = slug.split(\"/\")[1] || \"\";\n        if (normalize(title).includes(normalize(query.query))) {\n          results.push({\n            id: id,\n            title: title,\n            url: `${this.baseUrl}${slug}`,\n            subOrDub: query.dub ? \"dub\" : \"sub\",\n          });\n        }\n      }\n    }\n\n    return results.slice(0, 20);\n  }\n\n  async findEpisodes(id: string): Promise<Episode[]> {\n    const [animeId, subOrDub] = id.split(\"/\");\n    const episodesUrl = `${this.baseUrl}/ajax/v2/episode/list/${animeId}`;\n    const res = await fetch(episodesUrl, {\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"Referer\": `${this.baseUrl}/series/${animeId}`,\n      },\n    });\n    const json = await res.json();\n    const episodes: Episode[] = [];\n\n    if (json.html) {\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(json.html, \"text/html\");\n      const epItems = doc.querySelectorAll(\"ul li a\");\n      for (const epItem of epItems) {\n        const epNum = parseInt(epItem.getAttribute(\"data-number\") || \"0\");\n        const epId = epItem.getAttribute(\"data-ep\") || \"\";\n        if (epNum > 0) {\n          episodes.push({\n            id: `${animeId}/${subOrDub}/${epId}`,\n            number: epNum,\n            title: `Episode ${epNum}`,\n            url: \"\",\n          });\n        }\n      }\n    }\n\n    return episodes.reverse(); // Chronological order\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    const [animeId, subOrDub, epId] = episode.id.split(\"/\");\n    const serverUrl = `${this.baseUrl}/ajax/v2/episode/servers?episodeId=${epId}`;\n\n    try {\n      const res = await fetch(serverUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Referer\": `${this.baseUrl}/watch/${animeId}/${epId}`,\n        },\n      });\n      const json = await res.json();\n\n      if (json.link && json.link.embed) {\n        // Embed URL, often VidSrc or similar\n        let streamUrl = json.link.embed.url;\n        if (streamUrl.includes(\"vidsrc\")) {\n          // VidSrc proxy for multi-quality\n          const vidSrcProxy = `${this.baseUrl}/vidcdn/embed-${epId}`; // Adjust if needed\n          streamUrl = await this.fetchVidSrc(vidSrcProxy, subOrDub);\n        }\n\n        return {\n          name: subOrDub.toUpperCase(),\n          url: streamUrl,\n          referrer: this.baseUrl,\n          headers: { \"Referer\": this.baseUrl },\n          requires: [],\n          hasSubtitles: subOrDub === \"sub\",\n        };\n      }\n\n      throw new Error(\"No embed found\");\n    } catch (err) {\n      // Fallback to external VidSrc if site-specific fails\n      const fallbackUrl = `https://vidsrc.me/embed/${episode.id}/600/1${subOrDub === 'dub' ? '?dub=true' : ''}`;\n      return {\n        name: \"VidSrc Fallback\",\n        url: fallbackUrl,\n        referrer: \"https://vidsrc.me\",\n        headers: {},\n        requires: [],\n        hasSubtitles: subOrDub === \"sub\",\n      };\n    }\n  }\n\n  private async fetchVidSrc(proxyUrl: string, subOrDub: string): Promise<string> {\n    const html = await fetch(proxyUrl, {\n      headers: { \"Referer\": this.baseUrl },\n    }).then(res => res.text());\n    const iframeMatch = html.match(/src=[\\\"'](.*vidstream|cakes|dood)/);\n    return iframeMatch ? iframeMatch[1] : \"\";\n  }\n}"
}
