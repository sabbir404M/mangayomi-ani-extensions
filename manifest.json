{
  "id": "aniwave",
  "name": "Aniwave",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/example/online-stream-providers/main/aniwave/manifest.json",
  "language": "typescript",
  "type": "onlinestream-provider",
  "description": "Aniwave is an online streaming provider for anime with sub and dub support.",
  "author": "Swakshan",
  "icon": "https://raw.githubusercontent.com/Swakshan/mangayomi-swak-extensions/main/javascript/icon/en.aniwave.jpg",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private baseUrl = \"https://aniwave.to\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    // --- normalize helpers ---\n    const normalize = (title) => {\n      return (title || \"\")\n        .toLowerCase()\n        .replace(/(season|cour|part)/g, \"\") // strip keywords\n        .replace(/\\d+(st|nd|rd|th)/g, (m) => m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffixes\n        .replace(/[^a-z0-9]+/g, \"\") // remove non-alphanumeric\n        .replace(/(?<![i])ii(?!i)/g, \"2\"); // replace II with 2\n    };\n\n    const normalizeTitle = (title) => {\n      return (title || \"\")\n        .toLowerCase()\n        .replace(/(season|cour|part|uncensored)/g, \"\") // strip keywords\n        .replace(/\\d+(st|nd|rd|th)/g, (m) => m.replace(/st|nd|rd|th/, \"\")) // remove ordinal suffixes\n        .replace(/[^a-z0-9]+/g, \"\"); // remove non-alphanumeric\n    };\n    \n    const normalizeDate = (dateStr: string) => {\n      if (!dateStr) return null;\n      const months: Record<string, string> = {\n        Jan: \"01\", Feb: \"02\", Mar: \"03\", Apr: \"04\",\n        May: \"05\", Jun: \"06\", Jul: \"07\", Aug: \"08\",\n        Sep: \"09\", Oct: \"10\", Nov: \"11\", Dec: \"12\",\n      };\n      const m = dateStr.match(/([A-Za-z]+)\\s+\\d{1,2},\\s*(\\d{4})/);\n      if (!m) return null;\n      return { year: parseInt(m[2]), month: parseInt(months[m[1]]) };\n    };\n\n    const levenshteinSimilarity = (a, b) => {\n      const lenA = a.length;\n      const lenB = b.length;\n      const dp = Array.from({ length: lenA + 1 }, () => new Array(lenB + 1).fill(0));\n    \n      for (let i = 0; i <= lenA; i++) dp[i][0] = i;\n      for (let j = 0; j <= lenB; j++) dp[0][j] = j;\n    \n      for (let i = 1; i <= lenA; i++) {\n        for (let j = 1; j <= lenB; j++) {\n          if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n          else dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n        }\n      }\n    \n      const distance = dp[lenA][lenB];\n      const maxLen = Math.max(lenA, lenB);\n      return 1 - distance / maxLen; // similarity in range [0,1]\n    };\n  \n    const start = query.media.startDate;\n    const targetNormJP = normalize(query.media.romajiTitle);\n    const targetNorm = query.media.englishTitle\n      ? normalize(query.media.englishTitle)\n      : targetNormJP;\n  \n    const fetchMatches = async (url: string) => {\n      const html = await fetch(url, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n        },\n      }).then(res => res.json());\n  \n      return html.items?.map((movie: any) => ({\n        id: movie.id,\n        pageUrl: movie.slug,\n        title: movie.title,\n        titleJP: movie.japanese_title || movie.title,\n        normTitleJP: normalize(movie.japanese_title || movie.title),\n        normTitle: normalize(movie.title),\n        dub: movie.has_dub || false,\n        startDate: normalizeDate(movie.release_date),\n      })) ?? [];\n    };\n  \n    // Base search\n    const url = `https://api.aniwave.to/v2/anime/search?keyword=${encodeURIComponent(query.query)}&limit=48`;\n    const matches = await fetchMatches(url);\n    if (!matches.length) return [];\n  \n    // If dub requested, filter only dub-capable matches\n    if (query.dub) matches = matches.filter(m => m.dub);\n\n    // Filter results prioritizing exact match title & start year/month -> match title & start year\n    let filtered = matches.filter(m => {\n      const titleMatch =\n        m.normTitle === targetNorm ||\n        m.normTitleJP === targetNormJP;\n    \n      const dateMatch =\n        (m.startDate?.year === start?.year) &&\n        (m.startDate?.month === start?.month);\n\n      return titleMatch && dateMatch;\n    });\n\n    if (!filtered.length) {\n      filtered = matches.filter(m => {\n        const titleMatch =\n          m.normTitle === targetNorm ||\n          m.normTitleJP === targetNormJP;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year)\n        return titleMatch && dateMatch;\n      });\n    }\n\n    if (!filtered.length) {\n      filtered = matches.filter(m => {\n        const titleMatch =\n          m.normTitle.includes(targetNorm) ||\n          m.normTitleJP.includes(targetNormJP) ||\n          targetNorm.includes(m.normTitle) ||\n          targetNormJP.includes(m.normTitleJP) ||\n          levenshteinSimilarity(m.normTitle, targetNorm) > 0.7 ||\n          levenshteinSimilarity(m.normTitleJP, targetNormJP) > 0.7;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year) &&\n          (m.startDate?.month === start?.month);\n        \n        return titleMatch && dateMatch;\n      });\n    }\n\n    if (!filtered.length) {\n      filtered = matches.filter(m => {\n        const titleMatch =\n          m.normTitle.includes(targetNorm) ||\n          m.normTitleJP.includes(targetNormJP) ||\n          targetNorm.includes(m.normTitle) ||\n          targetNormJP.includes(m.normTitleJP) ||\n          levenshteinSimilarity(m.normTitle, targetNorm) > 0.7 ||\n          levenshteinSimilarity(m.normTitleJP, targetNormJP) > 0.7;\n\n        const dateMatch =\n          (m.startDate?.year === start?.year)\n        return titleMatch && dateMatch;\n      });\n    }\n  \n    // Return results\n    let results = filtered.map(m => ({\n      id: `${m.id}/${query.dub ? \"dub\" : \"sub\"}`,\n      title: m.title,\n      url: `${this.baseUrl}/anime/${m.pageUrl}`,\n      subOrDub: query.dub ? \"dub\" : \"sub\",\n    }));\n\n    if (!query.media.startDate || !query.media.startDate.year) {\n      filtered = matches.filter(m => {\n        const titleMatch =\n          normalizeTitle(m.title) === normalizeTitle(query.query) ||\n          normalizeTitle(m.titleJP) === normalizeTitle(query.query) ||\n          normalizeTitle(m.title).includes(normalizeTitle(query.query)) ||\n          normalizeTitle(m.titleJP).includes(normalizeTitle(query.query)) ||\n          normalizeTitle(query.query).includes(normalizeTitle(m.title)) ||\n          normalizeTitle(query.query).includes(normalizeTitle(m.titleJP));\n        return titleMatch;\n      });\n      filtered.sort((a, b) => {\n        const A = normalizeTitle(a.title);\n        const B = normalizeTitle(b.title);\n      \n        // 1) Sort by length\n        if (A.length !== B.length) {\n          return A.length - B.length;\n        }\n      \n        // 2) If lengths match, sort alphabetically\n        return A.localeCompare(B);\n      });\n      results = filtered.map(m => ({\n        id: `${m.id}/${query.dub ? \"dub\" : \"sub\"}`,\n        title: m.title,\n        url: `${this.baseUrl}/anime/${m.pageUrl}`,\n        subOrDub: query.dub ? \"dub\" : \"sub\",\n      }));\n    }\n  \n    return results;\n  }\n\n  async findEpisodes(Id: string): Promise<Episode[]> {\n    const [id, subOrDub] = Id.split(\"/\");\n\n    const epRes = await fetch(\n      `https://api.aniwave.to/v2/anime/${id}/episodes`,\n      {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n        },\n      }\n    );\n\n    const epJson = await epRes.json();\n    const episodes: Episode[] = [];\n\n    for (const ep of epJson.episodes || []) {\n      episodes.push({\n        id: `${id}/${subOrDub}`,\n        number: ep.number,\n        title: ep.title || `Episode ${ep.number}`,\n        url: \"\",\n      });\n    }\n\n    return episodes;\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    const [id, subOrDub] = episode.id.split(\"/\");\n  \n    const sourceUrl = `https://api.aniwave.to/v2/episode/sources?id=${id}&episodeId=${episode.number}&server=${subOrDub === 'dub' ? 'vidstream' : 'default'}&type=hard`;  // Assuming hard sub for sub, adjust for dub\n  \n    try {\n      const res = await fetch(sourceUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n        },\n      });\n  \n      const json = await res.json();\n      const sources = json.sources || [];\n      const source = sources.find((s: any) => s.quality === 'default' && s.url) || sources[0];\n      if (!source) throw new Error(\"No video sources found\");\n  \n      // Decrypt or direct if needed (Aniwave sources may be encrypted; add decrypter if required)\n      let streamUrl = source.url;\n      if (streamUrl.startsWith('encrypted:')) {\n        // Placeholder for decrypter logic, e.g., similar to Anicrush\n        streamUrl = await this.decryptSource(streamUrl);  // Implement decryptSource method if needed\n      }\n  \n      return {\n        name: \"Default\",\n        url: streamUrl,\n        referrer: this.baseUrl,\n        headers: {},\n        requires: [],\n        hasSubtitles: true,\n      };\n    } catch (err) {\n      throw new Error(`Failed to fetch episode server: ${err.message}`);\n    }\n  }\n\n  private async decryptSource(encryptedUrl: string): Promise<string> {\n    // Placeholder: Implement decryption logic specific to Aniwave if needed (e.g., using external decrypter API)\n    // For now, return as-is or log warning\n    console.warn(\"Decryption placeholder for Aniwave source\");\n    return encryptedUrl.replace('encrypted:', '');\n  }\n}"
}
